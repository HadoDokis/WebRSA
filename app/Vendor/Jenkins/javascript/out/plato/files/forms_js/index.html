<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - forms.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>forms.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.17</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">816</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">90.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.37</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*global console, validationJS, document, validationRules, validationOnsubmit, traductions, Validation, validationOnchange, setTimeout, $, $$*/

/**
 * Polyfill, à déplacer
 * 
 * @source https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/create#Polyfill
 */
if (typeof Object.create !== &#039;function&#039;) {
  Object.create = (function() {
	&#039;use strict&#039;;
    var Temp = function() { return; };
    return function (prototype) {
      if (arguments.length &gt; 1) {
        throw new Error(&#039;Cette prothèse ne supporte pas le second argument&#039;);
      }
      if (typeof prototype !== &#039;object&#039;) {
        throw new TypeError(&#039;L\&#039;argument doit être un objet&#039;);
      }
      Temp.prototype = prototype;
      var result = new Temp();
      Temp.prototype = null;
      return result;
    };
  }());
}

// -----------------------------------------------------------------------------

/*
 * Fait le lien entre FormValidatorHelper et webrsa.validaterules.js
 * Permet la vérification des données d&#039;un formulaire en fonction des règles de validation
 * contenu dans les models. Empèche l&#039;envoi du formulaire et affiche les érreurs si les données
 * ont mal été rempli.
 * 
 * @package app.View.Helper
 * @subpackage FormValidator
 * @license CeCiLL V2 (http://www.cecill.info/licences/Licence_CeCILL_V2-fr.html)
 */
var rules = [];
var values = {};
var editableList = {};

// Lié au debug, mettre impérativement à false en production !
var debugMode = true;
var verbose = false;
var ultraVerbose = false;

function giveDefaultValue( valeur, defaultValue ){
	&#039;use strict&#039;;
	return valeur === undefined ? defaultValue : valeur;
}

/**
 * On lui donne un nom d&#039;editable et il renvoi le nom du model dont il dépend
 * getModelName( data[Monmodel][Mon_field] ) = &#039;Monmodel&#039;
 * 
 * @param {String} name
 * @returns {String} ModelName
 */
function getModelName( name ){
	&#039;use strict&#039;;
	var crochet1, crochet2;
	crochet1 = name.indexOf(&#039;[&#039;);
	crochet2 = name.indexOf(&#039;]&#039;);
	
	// Il doit exister au moins une paire de crochets
	if ( crochet1 === -1 || crochet2 === -1 ){
		return null;
	}
	
	return name.substr(crochet1 +1, crochet2 - crochet1 -1);
}

/**
 * On lui donne un nom d&#039;editable et il renvoi le nom du champ dont il dépend
 * getModelName( data[Monmodel][Mon_field] ) = &#039;Mon_field&#039;
 * 
 * @param {String} name
 * @returns {String} ModelName
 */
function getFieldName( name ){
	&#039;use strict&#039;;
	var crochet1, crochet2, crochet3, crochet4;
	crochet1 = name.indexOf(&#039;[&#039;);
	crochet2 = name.indexOf(&#039;]&#039;);
	crochet3 = name.indexOf(&#039;[&#039;, crochet1 +1);
	crochet4 = name.indexOf(&#039;]&#039;, crochet2 +1);
	
	// Il doit exister au moins 2 paires de crochets
	if ( crochet1 === -1 || crochet2 === -1 || crochet3 === -1 || crochet4 === -1 ){
		return null;
	}
	
	// Renvoi le contenu de la deuxieme paire de crochets
	return name.substr(crochet3 +1, crochet4 - crochet3 -1);
}

/**
 * Fonctionne comme getModelName(),
 * Permet d&#039;obtenir le contenu de la 3e paire de crochets (utile pour les dates)
 * 
 * @param {String} name
 * @returns {String}
 */
function getThirdParam( name ){
	&#039;use strict&#039;;
	var crochets = /^[^\[]*(\[[^\]]*\]){2}\[([^\]]*)\].*$/g,
		result = crochets.exec( name );

	if( result === null || result.length &lt; 3 ) {
		return null;
	}
	
	return result[2];
}

/**
 * Affiche message en console
 * Nécéssite l&#039;activation du debug au préalable
 * Si v est à true, affichera le message seulement si verbose est activé
 * Si vplus est à true, affichera le message seulement si ultraVerbose est activé
 * Condition permet d&#039;ajouter une condition suplémentaire
 * 
 * @param {Mixed} message
 * @param {Boolean} v (verbose)
 * @param {Boolean} vplus (ultraVerbose)
 * @param {Boolean} condition
 * @returns {void}
 */
function debug( message, v, vplus, condition ){
	&#039;use strict&#039;;
	if ( condition === undefined || condition ){
		v = giveDefaultValue( v, false );
		vplus = giveDefaultValue( vplus, false );

		if ( debugMode &amp;&amp; ((v &amp;&amp; verbose) || !v) &amp;&amp; ((vplus &amp;&amp; ultraVerbose) || !vplus) ){
			console.log( message );
		}
	}
}

/**
 * Récupère les params d&#039;une rule
 * 
 * @param {Object} rule
 * @returns {Array}
 */
function getParams( rule ){
	&#039;use strict&#039;;
	var	i,
		varParams = [];
	
	for (i=1; i&lt;rule.length; i++){
		varParams.push( rule[i] );
	}
	
	return varParams;
}

/**
 * Lié à getRules() ajoute une nouvelle règle de validation à un editable
 * 
 * @param {Object} contain
 * @returns {Object}
 */
function addRule( contain ){
	&#039;use strict&#039;;
	var		rule = [], 
			varAllowEmpty = contain.allowEmpty !== undefined ? contain.allowEmpty : false, 
			varParams = [], 
			message,
			ruleName;
	
	// Si le nom de la regle est un String
	if ( typeof contain.rule === &#039;string&#039; ) {
		ruleName = contain.rule;		
	}
	
	// Si le nom de la regle est stocké dans un array
	else{
		varParams = getParams( contain.rule );
		
		// Note: contain.rule[0] est l&#039;exacte position du nom de règle dans le cas d&#039;un array		
		ruleName = contain.rule[0];
	}
	
	message = contain.message || (traductions[ruleName] || null);
	rule = {name: ruleName, allowEmpty: varAllowEmpty, params: varParams, message: message};
	
	debug( (&#039;addRule( contain ) - var rule :&#039;), true, true );
	debug( rule, true, true );
	return rule;
}

/**
 * extractRules() constitue le moteur de getRules() (Qui lui, effectue des vérifiactions avant)
 * 
 * @param {Object} validation
 * @returns {Object}
 */
function extractRules( validation ){
	&#039;use strict&#039;;
	var key, contain, rules = [];
	
	// Recherche les regles de validation pour ce champ
	for (key in validation){
		if (validation.hasOwnProperty(key)){
			contain = validation[key];
			debug( (&#039;getRules( name ) - var contain :&#039;), true, true );
			debug( contain, true, true );

			if ( contain.rule !== undefined ){
				rules.push( addRule( contain ) );
			}
			else{
				debug( (&#039;pas de rule trouvé&#039;) );
				debug( contain, true );
			}
		}
	}
	
	debug( &#039;&#039;, true, true );
	return rules;
}

/**
 * Récupère la règle de validation en fonction du nom de l&#039;editable
 * 
 * @param {String} name
 * @returns {Object|Boolean}
 */
function getRules( name ){
	&#039;use strict&#039;;
	var modelName, fieldName, rules;
	// Si le json n&#039;existe pas, on renvoi FALSE (on ne peut pas valider sans)
	if ( validationRules === undefined ) {
		return false;
	}
	
	modelName = getModelName( name );
	fieldName = getFieldName( name );
	
	// Si aucune vérification n&#039;a été trouvé, le champ est correct quoi qu&#039;il arrive
	if ( validationRules[modelName] === undefined || validationRules[modelName][fieldName] === undefined ){
		return null;
	}
	
	rules = extractRules( validationRules[modelName][fieldName] );
	
	return rules;
}

/**
 * Concatene les champs date et renvoi leurs valeurs
 * 
 * @param {Object} listedEditable
 * @returns {String}
 */
function extractDate( listedEditable ){
	&#039;use strict&#039;;
	var thisDate = {day: &#039;&#039;, month: &#039;&#039;, year: &#039;&#039;},
		thirdParam, i;
	
	for ( i=0; i&lt;3; i++ ){
		// On récupère day, month ou year et on l&#039;affecte a la variable thisDate
		thirdParam = getThirdParam( listedEditable[i].editable.name );
		switch ( thirdParam ){
			case &#039;day&#039;: 
			case &#039;month&#039;:
			case &#039;year&#039;: thisDate[thirdParam] = listedEditable[i].editable.value; break;
			default: return false; // Si ne contien pas day, month ou year, c&#039;est que ce n&#039;est pas une date !
		}
	}
	
	return thisDate;
}

/**
 * Permet de gérer les elements dates (tordu) de cakephp (les 3 selects)
 * On lui donne un nom de champ (peut importe si c&#039;est data[Model][field][day] ou data[Model][field][year]...)
 * Il renvoi la date au format 01-01-2015
 * 
 * @param {String} name
 * @returns {String}
 */
function getDate ( name ){
	&#039;use strict&#039;;
	var formatedName, thisDate;
	// Converti le name de la forme data[Model][field][day] en Model.field
	formatedName = getModelName( name ) + &#039;.&#039; + getFieldName( name );
	
	// Il doit y avoir 3 Model.field stocké ( day, month et year )
	if ( editableList[formatedName] === undefined || editableList[formatedName].length !== 3 || formatedName === &#039;null.null&#039; ){
		return false;
	}
	
	thisDate = extractDate( editableList[formatedName] );
	
	if ( !thisDate ){
		return false;
	}
	
	return thisDate.day + &#039;-&#039; + thisDate.month + &#039;-&#039; + thisDate.year;
}

/**
 * Renvoi la valeur se trouvant après le séparateur (&#039;_&#039; par defaut)
 * @param {String} value
 * @param {String} separator
 * @returns {String}
 */
function suffix( value, separator ){
	&#039;use strict&#039;;
	separator = giveDefaultValue ( separator, &#039;_&#039; );
	var cutPos = value.indexOf(separator) + separator.length;
	return cutPos &gt; 0 ? value.substr(cutPos, value.length) : value;
}

/**
 * Dans le cas d&#039;un fieldName avec un _id, revoi si possible le suffix de cette valeur
 * @param {HTML} editable
 * @param {String} value
 * @returns {String}
 */
function formatValue( editable, value ){
	&#039;use strict&#039;;
	var fieldName = getFieldName( editable.name );
	if ( fieldName.match(/_id/) ){
		value = suffix( value );
	}
	
	return value.trim();
}

/**
 * Récupère la valeur des boutons radio (renvoi la valeur du bouton selectionné)
 * 
 * @param {type} targets
 * @returns {getRadioValue.valeur}
 */
function getRadioValue( targets ){
	&#039;use strict&#039;;
	var i, valeur;
	for ( i=0; i&lt;targets.length; i++ ){
		if ( targets[i].checked === true ){
			valeur = String( targets[i].value );
			return valeur;
		}
	}
}

/**
 * Renvoi la valeur réelle d&#039;un editable
 * Cherche les élements du même model et même field
 * 
 * @param {HTML} editable
 * @returns {String}
 */
function getValue( editable ){
	&#039;use strict&#039;;
	var targets, thisDate, valeur, cas;
	if ( rules[editable.index] === undefined ){
		return null;
	}

	targets = $$(&#039;[name=&quot;&#039; + rules[editable.index].name + &#039;&quot;]&#039;);
	
	// Cas Date
	thisDate = getDate( rules[editable.index].name );
	cas = thisDate ? &#039;date&#039; : (	(editable.sectedIndex !== undefined || targets.length === 1) ? &#039;normal&#039; : &#039;radio&#039;);
	
	switch ( cas ){
		case &#039;date&#039;: valeur = thisDate; break;
		case &#039;normal&#039;: valeur = String( editable.value ); break;
		case &#039;radio&#039;: valeur = getRadioValue( targets ); break;
		default: debug( &#039;/!\\ BUG /!\\ valeur non trouvé dans &#039; + editable.name ); return null;
	}
	
	values[rules[editable.index].name].value = valeur;
	debug( (&#039;Valeur trouvé : &#039; + valeur), true, true );
	return thisDate || formatValue( editable, valeur );
}

/**
 * Permet le retrait d&#039;un message d&#039;erreur lié à un editable
 * 
 * @param {HTML} editable
 * @returns {Boolean}
 */
function removeError( editable ){
	&#039;use strict&#039;;
	var parentDiv, errorDiv;
	if ( editable === undefined ){
		return false;
	}
	
	// On remonte vers la div maman pour chercher une erreur à l&#039;interieur
	parentDiv = editable.up(&#039;div&#039;);
	parentDiv.removeClassName(&#039;error&#039;);
	
	errorDiv = parentDiv.select(&#039;div.error-message&#039;);
	
	// Si on trouve une erreur affiché, on la retire
	if ( errorDiv !== undefined &amp;&amp; errorDiv[0] !== undefined ){
		errorDiv[0].remove();
	}
}

/**
 * Affiche l&#039;érreur lié à un editable (ex: Champ obligatoire)
 * 
 * @param {HTML} editable
 * @param {String} message
 * @returns {Boolean}
 */
function showError( editable, message ){
	&#039;use strict&#039;;
	var parentDiv, errorMsg;
	if ( editable === undefined){
		return false;
	}
	
	// Si aucun message n&#039;est indiqué, on affiche Champ obligatoire, sinon le message
	message = message === undefined || message === null ? &#039;Champ obligatoire&#039; : message;
	
	// On attribu la class error à la div maman de l&#039;editable
	parentDiv = editable.up(&#039;div&#039;);
	parentDiv.addClassName(&#039;error&#039;);
	
	// On verifi si un message d&#039;erreur existe deja
	errorMsg = parentDiv.getElementsByClassName(&#039;error-message&#039;);
	
	// On ajoute le message si il n&#039;y en a pas d&#039;autres
	if ( errorMsg.length === 0 ){
		parentDiv.insert(&#039;&lt;div class=&quot;error-message&quot;&gt;&#039; + message + &#039;&lt;/div&gt;&#039;);
	}
}

/**
 * Récupère et formate les params de rule
 * 
 * @param {HTML} editable
 * @param {Number} i
 * @returns {Object}
 */
function getRulesParams( editable, i ){
	&#039;use strict&#039;;
	var params, modelName, targetName, target, name,
	ruleName = rules[editable.index].rules[i].name;
	params = Object.create( rules[editable.index].rules[i].params );
	name = rules[editable.index].name;

	// Validation manquante...
	if ( Validation[ruleName] === undefined ){
		debug( (&#039;Validation manquante : &#039; + ruleName) );
		debug( params, true );
		return undefined;
	}

	// Cas particulier : notEmptyIf
	if ( ruleName === &#039;notEmptyIf&#039; ){
		modelName = getModelName( name );
		targetName = &#039;data[&#039; + modelName + &#039;][&#039; + params[0] + &#039;]&#039;;
		target = $$(&#039;[name=&quot;&#039; + targetName + &#039;&quot;]&#039;)[0];

		if ( target === undefined ){
			debug( (&#039;Cible du notEmptyIf non trouvé! &#039;+targetName), true );
			debug( (&#039;index = &#039;+editable.index), true );
			debug( (rules[editable.index]), true );
			return undefined;
		}
		params[0] = getValue( target ); 
		debug( (&#039;Target.value = &#039;+params[0]+&#039;; condition = &#039;+params[1]), true ); 
		debug( (params[2]), true );
	}
	
	return params;
}

/**
 * Valide ou pas l&#039;editable concerné et affiche l&#039;erreur le cas échéan
 * 
 * @param {HTML} editable
 * @param {String} value
 * @param {Number} i
 * @param {Object} params
 * @param {Boolean} isOnchange
 * @returns {Boolean}
 */
function isValid( editable, value, i, params, isOnchange ){
	&#039;use strict&#039;;
	var message,
		ruleName = rules[editable.index].rules[i].name,
		validation = false;

	// C&#039;est maintenant qu&#039;on vérifie l&#039;editable
	switch ( params.length ){
		case 0: validation = Validation[ruleName]( value ); break;
		case 1: validation = Validation[ruleName]( value, params[0] ); break;
		case 2: validation = Validation[ruleName]( value, params[0], params[1] ); break;
		case 3: validation = Validation[ruleName]( value, params[0], params[1], params[2] ); break;
	}

	// Si la validation à échoué
	if ( !validation ){
		debug( (ruleName+&#039; = false&#039;) );

		if ( validationOnchange &amp;&amp; isOnchange ){
			message = rules[editable.index].rules[i].message;
			debug([
				getModelName( editable.name ),
				getFieldName( editable.name ),
				validationRules[getModelName( editable.name )][getFieldName( editable.name )],
				message
			], true);
			showError( editable, message );
		}

		return false;
	}
	
	return true;
}

/**
 * Décide ou pas d&#039;effectuer la verification d&#039;un editable
 * 
 * @param {HTML} editable
 * @param {Boolean} onchange
 * @returns {Boolean}
 */
function doValidation( editable, onchange ){
	&#039;use strict&#039;;
	var i, params, rule, value;
	
	rule = rules[editable.index].rules;
	value = getValue( editable );

	debug( (&#039;-------------------- validation &#039;+editable.name+&#039; --------------------&#039;) );
	debug( (&#039;Valeur = &#039;+value), true );
	
	if ( rule === null || rule.length &lt;= 0 ){
		return true;
	}
	
	// Un editable peut avoir plusieurs regles de validations...
	for (i=0; i&lt;rule.length; i++){
		params = getRulesParams( editable, i );
		
		if( params !== undefined &amp;&amp; !isValid( editable, value, i, params, onchange ) ) {
			return false;
		}
	}

	// Il n&#039;y a pas eu de return false, c&#039;est que l&#039;editable a passer les tests
	debug( rules[editable.index].rules[0].name+&#039; = true&#039; );
	
	return true;
}

/**
 * Moteur de validation (utilise webrsa.validaterules.js)
 * Vérifi un editable
 * Renseigner onchange permet ou pas l&#039;affichage du message d&#039;érreur du champ (lié à l&#039;evenement onchange)
 * Fonctionne avec doValidation()-&gt;isValid()
 * 
 * @param {HTML} editable
 * @param {Boolean} onchange
 * @returns {Boolean}
 */
function validate( editable, onchange ){
	&#039;use strict&#039;;
	if ( editable === undefined || editable === null || editable.index === undefined || rules[editable.index] === undefined ){
		return true;
	}
	
	// onchange permet l&#039;affichage des erreurs en true 
	// empeche les evenements comme onkeypress de déclancher l&#039;affichage d&#039;erreurs
	onchange = giveDefaultValue( onchange, false );
		
	// On retire l&#039;éventuel message d&#039;érreur
	if ( validationOnchange &amp;&amp; onchange ){
		removeError( editable );
	}

	return doValidation( editable, onchange );
}

/**
 * Affiche le message d&#039;erreur sous le menu de navigation (en haut)
 * 
 * @returns {undefined}
 */
function showHeaderError(){
	&#039;use strict&#039;;
	// Affiche le message d&#039;erreur si aucun message n&#039;est trouvé
	$$(&#039;#pageContent&gt;p.error, #incrustation_erreur&gt;p.error&#039;).each(function( obj ){ obj.remove(); });
	
	$(&#039;incrustation_erreur&#039;).innerHTML = &#039;&lt;p class=&quot;error&quot;&gt;&lt;img src=&quot;/img/icons/exclamation.png&quot; alt=&quot;Erreur&quot;&gt;	Erreur lors de l\&#039;enregistrement&lt;/p&gt;&#039;;
	
	// Scroll vers le message d&#039;erreur
	$$(&#039;#incrustation_erreur&gt;p.error&#039;)[0].scrollTo();
}

/**
 * Vérifi l&#039;intégralité des editables d&#039;un formulaire
 * 
 * @param {HTML} form
 * @returns {Boolean}
 */
function checkAll( form ){
	&#039;use strict&#039;;
	// Si variable rules n&#039;existe pas, on envoi le formulaire
	if ( rules === undefined ){
		return true;
	}
	
	var valid = true;
	
	// Pour chaque éditables... On vérifi la valeur...
	$$(&#039;#&#039; + form.id + &#039; input, #&#039; + form.id + &#039; select,&#039; + form.id + &#039; textarea&#039;).each( function( editable ){
		if ( !validate( $( editable ), true ) ){
			debug( (&#039;Validation échoué :&#039;) );
			debug( editable );
			valid = false;
		}
	});
	
	// Si un élément est faux, on n&#039;envoi pas le formulaire
	if ( !valid ){
		// Empeche les boutons submit de se griser
		$$(&#039;#&#039; + form.id + &#039; input[type=&quot;submit&quot;]&#039;).each( function( submitButton ){
			submitButton.removeAttribute(&#039;disabled&#039;);
		});
		debug( (&#039;/!\\ Le formulaire n\&#039;a pas été envoyé car il y a un ou plusieurs champs pas/mal rempli.&#039;) );
		
		// Affiche le message d&#039;érreur sous le menu de navigation
		showHeaderError();
		return false;
	}
	debug( (&#039;Validation réussie&#039;) );
	
	// Empeche les submit de se griser en mode debug
	if ( debugMode ){
		$$(&#039;#&#039; + form.id + &#039; input[type=&quot;submit&quot;]&#039;).each( function( submitButton ){
			submitButton.removeAttribute(&#039;disabled&#039;);
		});
	}
	
	// En mode debug, empeche l&#039;envoi du formulaire pour afficher en console les informations
	return !debug;
}

/**
 * Lié à validate()
 * Attend 10 milisecondes avant de vérifier
 * Indispensable lors de l&#039;utilisation des evenements onchange et onkeypress
 * (sinon l&#039;evenement est envoyé avant la modification effective du champ...)
 * 
 * @param {HTML} editable
 * @param {Boolean} onchange
 * @returns {Boolean}
 */
function validateWithTimeout( editable, onchange ){
	&#039;use strict&#039;;
	setTimeout( validate, 10, editable, onchange );
}

/**
 * Ajoute les evenements onchange, onclick et onsubmit sur les elements concernés.
 * 
 * @param {HTML} editable
 * @param {String} type
 * @returns {void}
 */
function addEvent( editable, type ){
	&#039;use strict&#039;;
	
	type = type === undefined ? &#039;editable&#039; : type;
	
	if ( type === &#039;editable&#039; ){
		// On lui attribu les evenements onchange et onkeypress qui déclancherons la validation
		editable.onchange = function(){
			// On ne lance la validation que si une différence est trouvé entre l&#039;ancienne et la nouvelle valeur
			getValue( this );
			if ( values[this.name].value !== values[this.name].oldValue ){
				validateWithTimeout( this, true );
			}
			values[this.name].oldValue = String( values[this.name].value );
		}; // jshint ignore:line

		editable.onkeypress = function(){
			values[this.name].oldValue = values[this.name].oldValue === null ? String( values[this.name].value ) : values[this.name].oldValue;
			getValue( this );
			// Lance la validation mais sans affichage d&#039;erreur
			validateWithTimeout( this, false );
		};
	}
	else{
		editable.onsubmit = function(){
			return checkAll( this );
		};
	}
}

/**
 * Initialise les objets en rapport avec les editables pour le traitement des vérifications
 * Leurs ajoute si besoin les evenements via addEvent()
 * 
 * @param {HTML} editables
 * @returns {void}
 */
function initEditables( editables ){
	&#039;use strict&#039;;
	var i, name, formatedName, editable;
	
	// On fait le tour de tout les editables
	for (i=0; i&lt;editables.length; i++){
		name = editables[i].name;
		editables[i].index = i;
		debug( (&#039;window.onload - Element &#039;+name), true, true );
		
		// Si l&#039;editable n&#039;a pas de nom, on passe à un autre
		if ( name === undefined || name === &#039;&#039; ){
			continue;
		}
		
		// Pour chaque editable, on lui attribu des regles de validations (voir getRules() )
		editable = {name: name, id: editables[i].id, rules: getRules(name)};
		
		// Si ne possède pas une/des règles de validation
		if ( editable.rules === null ){
			continue;
		}
		
		// Value permet de stocker les valeurs pour vérifier si un champ à été modifié
		values[name] = {value: null, oldValue: null};
		
		// Formate le nom en Model.field
		formatedName = getModelName( name ) + &#039;.&#039; + getFieldName( name );
		debug( (&#039;window.onload - Nom formaté &#039; + formatedName), true, true );

		// Permet de faire le lien entre les editables ayant le même nom formaté (même model, même champ)
		editableList[formatedName] = giveDefaultValue( editableList[formatedName], [] );
		editableList[formatedName].push( {editable: editables[i], form: $(editables[i]).up(&#039;form&#039;)} );
		
		debug( (&#039;window.onload - var editableList[formatedName] :&#039;), true, true );
		debug( (editableList[formatedName]), true, true );
		
		debug( (&#039;window.onload - var editable :&#039;), true, true );
		debug( editable, true, true );
		
		// On sauvegarde les regles pour cet editable
		rules[i] = editable; 

		// On sauvegarde la valeur de l&#039;editable
		values[name] = {value: null};
		getValue( editable );

		// On lui attribu les evenements onchange et onkeypress qui déclancherons la validation
		addEvent( editables[i] );
		
		debug( &#039;--------Fin de l\&#039;attribution de regles pour cet element---------&#039;, true, true );
		debug( &#039;&#039;, true, true );
		debug( &#039;&#039;, true, true );
	}
}

/**
 * Initialise les formulaires pour leur appliquer via addEvent() l&#039;evenement onsubmit
 * 
 * @param {type} forms
 * @returns {undefined}
 */
function initForms( forms ){
	&#039;use strict&#039;;
	var key;
	
	for (key in forms){
		if ( forms.hasOwnProperty(key) ){
			// Empeche l&#039;envoi d&#039;un formulaire non valide si validationOnsubmit est vrais (voir webrsa.inc)
			if ( validationOnsubmit !== 1 ){
				break;
			}
			// Envenement onsubmit sur le formulaire (lance une vérification complète)
			addEvent( forms[key], &#039;form&#039; );
		}
	}
}


/**
 * Attribu les règles de validation pour chaques input|select|textarea (editable)
 * Surveille égelement quelques evenements :
 * onsubmit sur les formulaires
 * onchange et onkeypress sur les editables
 * Utilise initEditables()|initForms() -&gt; addEvent()
 * 
 * @returns {Boolean}
 */
function init(){
	&#039;use strict&#039;;
	var editables, forms;
	if ( validationJS === 0 || validationRules === undefined ) {
		debug( (&#039;validationJS ou validationRules absent!&#039;) );
		return false;
	}
	
	// Editable fait référence à tout ce qui est modifiable par l&#039;utilisateur (input, select et textarea)
	editables = $$(&#039;form input, form select, form textarea&#039;);
	
	initEditables( editables );
	
	debug( &#039;------------------------rules--------------------------&#039;, true, true );
	debug( rules, true, true );
	debug( &#039;-------------------------end---------------------------&#039;, true, true );
	
	// On diférencie les formulaires
	forms = $$(&#039;form&#039;);
	
	initForms( forms );
}
document.observe( &quot;dom:loaded&quot;, init );</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
