<?php
	/**
	 * Source file for the AutovalidateBehavior class.
	 *
	 * PHP 5.3
	 *
	 * @package       app.Model.Behavior
	 * @license       MIT License (http://www.opensource.org/licenses/mit-license.php)
	 */

	/**
	 * AutovalidateBehavior class.
	 *
	 * @package       app.Model.Behavior
	 */
	class Autovalidate2Behavior extends ModelBehavior
	{
		public $settings = array();

		protected $_autoAddedPaths = array( );

		/**
		 * -> array( 'rule' => array( 'XXXXXXX'[, ...] ) )
		 *
		 * @param Model $model
		 * @param type $rule
		 * @return type
		 */
		public function formatValidationRule( Model $model, $rule ) {
			if( !is_array( $rule ) ) {
				$rule = array( 'rule' => array( $rule ) );
			}
			else if( !is_array( $rule['rule'] ) ) {
				$rule['rule'] = (array)$rule['rule'];
			}

			return $rule;
		}

		/**
		 *
		 * @param Model $model
		 * @param string $field
		 * @param mixed $validate
		 * @return void
		 */
		public function addValidationRule( Model $model, $field, $validate ) {
			$validate = $this->formatValidationRule( $model, $validate );
			$ruleName = $validate['rule'][0];

			if( strtolower( $ruleName ) != 'notempty' ) {
				$validate['allowEmpty'] = true;
			}

			if( !$this->hasValidationRule( $model, $field, $ruleName ) ) {
				if( isset( $model->validate[$field] ) ) {
					$this->_autoAddedPaths[] = "{$field}.".count( $model->validate[$field] );
				}
				else {
					$this->_autoAddedPaths[] = "{$field}.0";
				}
				$model->validate[$field][] = $validate;
			}
		}

		/**
		 *
		 * @param Model $model
		 * @param string $field
		 * @param string $ruleName
		 * @return boolean
		 */
		public function hasValidationRule( Model $model, $field, $ruleName ) {
			$validationRules = Hash::flatten( $model->validate );
			foreach( $validationRules as $path => $value ) {
				if( preg_match( "/^{$field}(\.|\.[0-9]+\.)rule/", $path ) && ( $value === $ruleName ) ) {
					return true;
				}
			}
			return false;
		}

		/**
		 *
		 * @param Model $model
		 * @param string $field
		 * @param mixed $rule
		 * @return boolean
		 */
		public function removeValidationRule( Model $model, $field, $rule ) {
			$removed = 0;
			$validationRules = Hash::flatten( $model->validate );
			foreach( $validationRules as $path => $value ) {
				$matches = array();
				if( preg_match( "/^({$field}(\.|\.[0-9]+\.))rule/", $path, $matches ) && ( $value == $rule ) ) {
					$model->validate = Hash::remove( $model->validate, trim( $matches[1], '.' ) );
					// TODO: __backValidation ? / disableValidationRule ?
					$removed++;
				}
			}
			return ( $removed > 0 );
		}

		/**
		 * Not null -> notEmpty
		 * FIXME: seulement quand pas de default ?
		 *
		 * @param Model $model
		 * @param array $fieldParams
		 * @return boolean
		 */
		protected function _isNotEmptyField( Model $model, $fieldParams ) {
			return ( $this->settings[$model->alias]['rules']['notEmpty'] && Set::check( $fieldParams, 'null' ) && $fieldParams['null'] == false );
		}

		/**
		 * string -> maxLength
		 *
		 * @param Model $model
		 * @param array $fieldParams
		 * @return boolean
		 */
		protected function _isMaxLengthField( Model $model, $fieldParams ) {
			return ( $this->settings[$model->alias]['rules']['maxLength'] && ( $fieldParams['type'] == 'string' ) && Set::check( $fieldParams, 'length' ) && is_numeric( $fieldParams['length'] ) );
		}

		/**
		 * integer -> integer (FIXME: dans le AppModel, dans ce behavior ?)
		 *
		 * @param Model $model
		 * @param array $fieldParams
		 * @return boolean
		 */
		protected function _isIntegerField( Model $model, $fieldParams ) {
			return ( $this->settings[$model->alias]['rules']['integer'] && $fieldParams['type'] == 'integer' );
		}

		/**
		 * float -> numeric
		 *
		 * @param Model $model
		 * @param array $fieldParams
		 * @return boolean
		 */
		protected function _isNumericField( Model $model, $fieldParams ) {
			return ( $this->settings[$model->alias]['rules']['numeric'] && $fieldParams['type'] == 'float' );
		}

		/**
		 * integer validation method
		 * (à partir de CakePHP 2, on peut aussi mettre des règles dans les behaviors)
		 *
		 * @param Model $model
		 * @param array $check
		 * @return boolean
		 */
		public function integer( Model $model, $check ) {
			if( !is_array( $check ) ) {
				return false;
			}

			$result = true;
			foreach( Set::normalize( $check ) as $value ) {
				$result = preg_match( '/^[0-9]+$/', $value ) && $result;
			}
			return $result;
		}

		/**
		 * For each field, deduce and add the following validation rules:
		 * notEmpty, maxLength, integer, numeric
		 *
		 * @param Model $model
		 * @param string $field
		 * @param array $params
		 * @return void
		 */
		protected function _addDefaultFieldValidationRules( Model $model, $field, $params ) {
			/// Prepare / cleanup
			/*if( Set::check( $model->validate, "{$field}.rule" ) ) {
				debug( $model->validate[$field] );
				$model->validate[$field] = array( $model->validate[$field] );
				debug( $model->validate[$field] );
			}*/

			if( $this->_isNotEmptyField( $model, $params ) && ( $field != $model->primaryKey ) ) {
				$this->addValidationRule( $model, $field, array( 'rule' => 'notEmpty' ) );
			}

			if( $this->_isMaxLengthField( $model, $params ) ) {
				$this->addValidationRule( $model, $field, array( 'rule' => array( 'maxLength', $params['length'] ), 'allowEmpty' => true ) );
			}

			if( $this->_isIntegerField( $model, $params ) ) {
				//$this->addValidationRule( $model, $field, array( 'rule' => 'numeric', 'allowEmpty' => true ) );
				$this->addValidationRule( $model, $field, array( 'rule' => 'integer', 'allowEmpty' => true ) );
			}

			if( $this->_isNumericField( $model, $params ) ) {
				$this->addValidationRule( $model, $field, array( 'rule' => 'numeric', 'allowEmpty' => true ) );
			}
		}

		/**
		 * Setup this behavior with the specified configuration settings.
		 *
		 * @param object $model Model using this behavior
		 * @param array $settings Configuration settings for $model
		 * @return void
		 */
		public function setup( Model $model, $config = array( ) ) {
			$cacheKey = $model->useDbConfig.'_'.Inflector::underscore( __CLASS__ ).'_'.Inflector::underscore( $model->alias );
			$validate = Cache::read( $cacheKey );

			if( $validate === false ) {
				$defaultConfig = array( // TODO
					'rules' => array(
						'notEmpty' => true,
						'maxLength' => true,
						'numeric' => true,
						'integer' => true,
						'numeric' => true,
					// 					'boolean' ?
					// 					'unsigned' ?
					),
					'domain' => 'default',
					'translate' => true
				);

				$config = Set::merge( $defaultConfig, $config );

				if( !isset( $this->settings[$model->alias] ) ) {
					$this->settings[$model->alias] = array();
				}

				$this->settings[$model->alias] = array_merge(
						$this->settings[$model->alias],
						(array)Set::normalize( $config )
				);

				$model->validate = Set::normalize( $model->validate );

				foreach( $model->schema() as $field => $params ) {
					$this->_addDefaultFieldValidationRules( $model, $field, $params );
				}

				$validate = $model->validate;
				Cache::write( $cacheKey, $validate );
//				$this->_autoAddedPaths
			}

			$model->validate = $validate;
		}

		/**
		 * Lorsque le behavior est détaché, on supprime les règles ajoutées.
		 * FIXME: si les règles ont bougé, on va peut-être en supprimer d'autres
		 *
		 * @param Model $model
		 * @return void
		 */
		public function cleanup( Model $model ) {
			parent::cleanup( $model );
			if( !empty( $this->_autoAddedPaths ) ) {
				foreach( $this->_autoAddedPaths as $path ) {
					$model->validate = Hash::remove( $model->validate, $path );
				}
				$model->validate = Hash::filter( (array)$model->validate );
			}
		}

		/**
		 * Adds a default translation to the validation rule.
		 * FIXME: traduction de Validate::integer ...
		 *
		 * @param Model $model
		 * @param string $field
		 * @param integer $key
		 * @param array $rule
		 * @param string $modelDomain
		 * @return void
		 */
		protected function _addDefaultRuleMessage( Model $model, $field, $key, $rule, $modelDomain ) {
			$validateRule = $model->validate[$field][$key]['rule'];
			if( is_array( $validateRule ) ) {
				$ruleName = $validateRule[0];
				$ruleParams = array_slice( $validateRule, 1 );
			}
			else {
				$ruleName = $validateRule;
				$ruleParams = array( );
			}

			$model->validate[$field][$key]['message'] = "Validate::{$ruleName}";

			$ruleDomain = Set::classicExtract( $rule, 'domain' );
			if( !empty( $ruleDomain ) ) {
				$domain = $ruleDomain;
			}
			else if( !empty( $modelDomain ) ) {
				$domain = $modelDomain;
			}
			else {
				$domain = null;
			}

			if( empty( $domain ) ) {
				$sprintfParams = Set::merge( array( __( $model->validate[$field][$key]['message'] ) ), $ruleParams );
			}
			else {
				$sprintfParams = Set::merge( array( __d( $domain, $model->validate[$field][$key]['message'] ) ), $ruleParams );
			}

			$model->validate[$field][$key]['message'] = call_user_func_array( 'sprintf', $sprintfParams );
		}

		/**
		 * Before validate callback, translate validation messages
		 *
		 * @param object $model Model using this behavior
		 * @return boolean True if validate operation should continue, false to abort
		 */
		public function beforeValidate( Model $model ) {
			if( Set::classicExtract( $this->settings, "{$model->alias}.translate" ) ) {
				$modelDomain = Set::classicExtract( $this->settings, "{$model->alias}.domain" );

				if( is_array( $model->validate ) ) {
					foreach( $model->validate as $field => $rules ) {
						foreach( $rules as $key => $rule ) {
							if( empty( $model->validate[$field][$key]['message'] ) ) {
								$this->_addDefaultRuleMessage( $model, $field, $key, $rule, $modelDomain );
							}
						}
					}
				}
			}

			return true;
		}
	}
?>