<?php
	if( !function_exists( 'addClassName' ) ) {
		function addClassName( $options, $className ) {
			$columnOptionsClass = Set::filter( explode( ' ', Set::classicExtract( $options, 'class' ) ) );
			$columnOptionsClass[] = $className;
			$options['class'] = implode( ' ', $columnOptionsClass );
			return $options;
		}
	}

	class DefaultHelper extends AppHelper
	{
        public $helpers = array( 'Html', 'Xpaginator', 'Locale', 'Xform' );

		/**
		* Cache for schemas
		*/

		protected $__columnTypes = array();

		/**
		* Extracts model name and field name from a path.
		* @param string $path ie. User.username, User.0.id
		* @return array( string $model, string $field ) ie. array( 'User', 'username' ), array( 'User', 'id' )
		*/

		protected function _modelField( $path ) {
			if( preg_match( "/(?<!\w)(\w+)(\.|\.[0-9]+\.)(\w+)$/", $path, $matches ) ) {
				return array( $matches[1], $matches[3] );
			}

			trigger_error( "Could not extract model and field names from the following path: \"{$path}\"", E_USER_WARNING );
			return null;
		}

		/**
		* @param string $path ie. User.username, User.0.id
		* @retrun string ie. string, integer
		*/

		protected function _fieldType( $path ) {
			list( $model, $field ) = $this->_modelField( $path );

			if( empty( $this->_columnTypes[$model] ) ) {
				$modelClass = ClassRegistry::init( Inflector::classify( $model ) );
				$this->_columnTypes[$model] = $modelClass->getColumnTypes( true );
			}

			if( !Set::check( $this->_columnTypes[$model], $field ) ) {
				trigger_error( "Could not find column {$field} in model {$model}", E_USER_WARNING );
				return null;
			}

			return Set::classicExtract( $this->_columnTypes[$model], $field );
		}

		/**
		* FIXME docs
		*/

        public function button( $type, $url, $htmlAttributes = array(), $confirmMessage = false, $escapeTitle = true ) {
            $enabled = ( isset( $htmlAttributes['enabled'] ) ? $htmlAttributes['enabled'] : true );
            $iconFileSuffix = ( ( $enabled ) ? '' : '_disabled' ); // TODO: les autres aussi

            switch( $type ) {
                case 'add':
                    $icon = 'icons/add'.$iconFileSuffix.'.png';
                    $text = __( 'Add', true );
                    break;
                case 'edit':
                    $icon = 'icons/pencil'.$iconFileSuffix.'.png';
                    $text = __( 'Edit', true );
                    break;
                case 'delete':
                    $icon = 'icons/delete'.$iconFileSuffix.'.png';
                    $text = __( 'Delete', true );
                    break;
                case 'process':
                    $icon = 'icons/lightning'.$iconFileSuffix.'.png';
                    $text = __( 'Process', true );
                    break;
                case 'view':
                    $icon = 'icons/zoom'.$iconFileSuffix.'.png';
                    $text = __( 'View', true );
                    break;
                case 'print':
                    $icon = 'icons/printer'.$iconFileSuffix.'.png';
                    $text = __( 'Imprimer', true );
                    break;
                case 'gedooo':
                    $icon = 'icons/printer'.$iconFileSuffix.'.png';
                    $text = __( 'Imprimer', true );
                    break;
                case 'printcohorte':
                    $icon = 'icons/printer'.$iconFileSuffix.'.png';
                    $text = __( 'Imprimer en cohorte', true );
                    break;
                case 'back':
                    $icon = 'icons/arrow_left'.$iconFileSuffix.'.png';
                    $text = __( 'Retour', true );
                    break;
                default:
                    $this->cakeError( 'error500' ); // FIXME -> proprement --> $this->cakeError( 'wrongParameter' )
            }

            $content = $this->Html->image( $icon, array( 'alt' => '' ) ).' '.$text;

            $class = implode(
                ' ',
                array(
                    'widget button',
                    $type,
                    ( $enabled ? 'enabled' : 'disabled' ),
                    ( isset( $htmlAttributes['class'] ) ? $htmlAttributes['class'] : null ),
                )
            );
            $htmlAttributes['class'] = $class;

			$htmlAttributes = array_filter_keys( $htmlAttributes, array( 'enabled' ), true );


            if( $enabled ) {
                return $this->Html->link(
                    $content,
                    $url,
                    $htmlAttributes,
                    $confirmMessage,
                    false
                );
            }
            else {
                return $this->Html->tag( 'span', $content, $htmlAttributes, false, false );
            }
        }

		/**
		* @param string $path ie. User.id, User.0.id
		* @param array $params
		* @return string
		* Valid keys for params:
		*	- domain
		*	- label
		*/

		public function label( $column, $options = array() ) {
			if( !Set::check( $options, 'label' ) ) {
				list( $currentModelName, $currentFieldName ) = $this->_modelField( $column );

				if( Set::check( $options, 'domain' ) && !empty( $options['domain'] ) ) {
					$domain = $options['domain'];
				}
				else {
					$domain = Inflector::singularize( Inflector::tableize( $currentModelName ) );
				}

				return __d( $domain, "{$currentModelName}.{$currentFieldName}", true );
			}
			else {
				return $options['label'];
			}
		}

		/**
		* @param array $datas
		* @param string $path ie. User.id
		* @param array $params
		* @return string
		* Valid keys for params:
		*	- model
		*	- type
		*	- domain -> FIXME: unneeded ?
		*	- tag
		*	- options ie. array( 'User' => array( 'status' => array( 1 => 'Enabled', 0 => 'Disabled' ) ) )
		*	- TODO: value et type
		*/

		public function format( $datas, $path, $params = array() ) {
			list( $modelName, $fieldName ) = $this->_modelField( $path );

			$defaultParams = array(
				'model' => $modelName,
				'type' => $this->_fieldType( $path ),
				'domain' => Inflector::singularize( Inflector::tableize( $modelName ) ),
				'tag' => false,
				'options' => null,
			);

			$classes = array();
			$params = Set::merge( $defaultParams, $params );
			$value = Set::classicExtract( $datas, $path );

			if( Set::classicExtract( $params, 'valueclass' ) ) {
				$classes = Set::merge( $classes, array( $fieldName, $value ) );
			}

			// If field is of "type enum", translate it
			if( Set::check( $params, "options.{$modelName}.{$fieldName}" ) ) {
				$domain = Inflector::singularize( Inflector::tableize( $modelName ) );
				$value = Set::enum( $value, Set::classicExtract( $params, "options.{$modelName}.{$fieldName}" ) );
				$value = __d( $domain, $value, true );
			}

			// Format entry and get classes
			$classes[] = $params['type'];
			switch( $params['type'] ) {
				// TODO: l10n + spÃ©cialisation des types
				case 'phone':
					$value = implode( '&nbsp;', str_split( $value, 2 ) );
					break;
				case 'money':
					$classes = Set::merge( $classes, array( 'number', ( ( $value >= 0 ) ? 'positive' : 'negative' ) ) );
					$value = $this->Locale->money( $value, 2 );
					break;
				/// SQL
				case 'boolean':
					switch( $value ) {
						case null:
							$value = '&nbsp;';
							$classes = Set::merge( $classes, array( 'number', 'null' ) );
							break;
						default:
							$classes = Set::merge( $classes, array( 'number', ( $value ? 'true' : 'false' ) ) );
							$value = ( $value ? __( 'Yes', true ) : __( 'No', true ) );
					}
					break;
				case 'float':
					$classes = Set::merge( $classes, array( 'number', ( ( $value >= 0 ) ? 'positive' : 'negative' ) ) );
					$value = $this->Locale->number( $value, 2 );
					break;
				case 'integer':
					$classes = Set::merge( $classes, array( 'number', ( ( $value >= 0 ) ? 'positive' : 'negative' ) ) );
					$value = $this->Locale->number( $value );
					break;
				case 'date':
				case 'time':
				case 'timestamp':
				case 'datetime':
					$value = $this->Locale->date( "Locale->{$params['type']}", $value );
					break;
				case 'string':
				case 'text':
					$value = ( !empty( $value ) ? $value : '&nbsp' );
					break;
				default:
					if( preg_match( '/^enum\(.*\)$/', $params['type'] ) ) {
						$classes[] = 'enum string';
						$value = ( !empty( $value ) ? $value : '&nbsp' );
					}
					else {
						trigger_error( "Unrecognized type {$params['type']}", E_USER_WARNING );
						return null;
					}
			}

			// Add non breakable spaces to numeric output if inside a tag
			if( !empty( $params['tag'] ) && in_array( $params['type'], array( 'integer', 'float', 'money' ) ) ) {
				$value = str_replace( ' ', '&nbsp;', $value );
			}

			// Format for inside a tag
			if( !empty( $params['tag'] ) ) {
// debug(  $classes );
				$params = addClassName( $params, implode( ' ', $classes ) );

				$value = $this->Html->tag(
					$params['tag'],
					$value,
					$params['class']
				);
			}

			return $value;
		}

		/**
		* @param string $path ie. User.id
		* @param array $params
		* @return string
		* Valid keys for params:
		*	- options ie. array( 'User' => array( 'status' => array( 1 => 'Enabled', 0 => 'Disabled' ) ) )
		*/

		public function field( $path, $params = array() ) {
			list( $modelName, $fieldName ) = $this->_modelField( $path );

			// If field is of "type enum", translate it
			if( Set::check( $params, "options.{$modelName}.{$fieldName}" ) ) {
				$params['options'] = Set::classicExtract( $params, "options.{$modelName}.{$fieldName}" );
			}
// debug( $params );
			return $this->Xform->input( $path, $params );
		}

		/**
		*
		*/

		public function thead( $columns, $params = array() ) {
			$thead = array();
			$actions = Set::classicExtract( $params, 'actions' );

			foreach( Set::normalize( $columns ) as $column => $options ) {
				$label = $this->label( $column, $options );

				if( Set::check( $this->Xpaginator->params, 'paging' ) ) {
					$thead[] = $this->Xpaginator->sort( $label, $column );
				}
				else {
					$thead[] = $label;
				}
			}

			$thead = $this->Html->tableHeaders( $thead );

			if( is_array( $actions ) && !empty( $actions ) ) {
				$thead = str_replace(
					'</tr>',
					'<th colspan="'.count( $actions ).'" class="action">Actions</th></tr>',
					$thead
				);
			}

			if( Set::check( $params, 'tooltip' ) ) {
				$thead = preg_replace( '/<\/tr>$/', "<th class=\"innerTableHeader noprint\">Informations complementaires</th></tr>", $thead );
			}

			return $this->Html->tag( 'thead', $thead );
		}

		/**
		*
		*/

		public function actions( $line, $params ) {
			$actions = Set::normalize( Set::classicExtract( $params, 'actions' ) );
			$tds = array();

			if( is_array( $actions ) && !empty( $actions ) ) {
				foreach( $actions as $action => $actionParams ) {
					list( $modelName, $action ) = $this->_modelField( $action );
					$domain = Inflector::singularize( Inflector::tableize( $modelName ) );
					$controller = Inflector::tableize( $modelName );
					$controllerName = Inflector::camelize( $modelName );
					$model = ClassRegistry::init( $modelName );

					// TODO
// 					foreach( array( 'controller', 'action' ) as $t ) {
// 						if( Set::check( $actionParams, $t ) ) {
// 							$$t = Set::classicExtract( $actionParams, $t );
// 						}
// 					}

					if( $action == 'delete' ) {
						$value = $this->button(
							'delete',
							array(
								'controller' => $controller,
								'action' => 'delete',
								Set::classicExtract( $line, "{$model->name}.{$model->primaryKey}" )
							),
							array(
								'title' => sprintf(
									__d( $domain, "{$controllerName}::{$action}", true ),
									Set::classicExtract( $line, "{$model->name}.{$model->displayField}" )
								)
							),
							sprintf(
								__d( $domain, "{$controllerName}::{$action}::confirm", true ),
								Set::classicExtract( $line, "{$model->name}.{$model->displayField}" )
							)
						);
					}
					else {
						$value = $this->button(
							$action,
							array(
								'controller' => $controller,
								'action' => $action,
								Set::classicExtract( $line, "{$model->name}.{$model->primaryKey}" )
							),
							array(
								'title' => sprintf(
									__d( $domain, "{$controllerName}::{$action}", true ),
									Set::classicExtract( $line, "{$model->name}.{$model->displayField}" )
								)
							)
						);
					}

					$tds[] = $this->Html->tag( 'td', $value, array( 'class' => 'action' ) );
				}
			}

			return implode( '', $tds );
		}

		/**
		* @param array $datas
		* @param array $cells ie. array( 'User.status' => array( 'domain' => 'Cohorte' ), 'User.userae' )
		* @param array $params
		* @return string
		* Valid keys for params:
		*	- domain
		*	- cohorte -> true/false
		*	- hidden
		*	- options ie. array( 'User' => array( 'status' => array( 1 => 'Enabled', 0 => 'Disabled' ) ) )
		* 	- TODO: tooltip
		*	- valuePath en paramÃ¨tre de chacun des input
		*/

		public function index( $datas, $cells, $cohorteParams = array() ) {
			/// FIXME: function
			$name = Inflector::camelize( $this->params['controller'] );
			$action = $this->action;
			$modelName = Inflector::classify( Inflector::tableize( $name ) );
			$modelClass = ClassRegistry::init( Inflector::classify( $modelName ) );
			$cohorte = Set::classicExtract( $cohorteParams, 'cohorte' );
			$domain = Inflector::singularize( Inflector::tableize( $modelName ) );
			///

			$cells = Set::normalize( $cells );
			$cohorteOptions = Set::classicExtract( $cohorteParams, "options" );
			$cohorteHidden = Set::classicExtract( $cohorteParams, "hidden" );

			if( Set::check( $cohorteParams, "id" ) ) {
				$containerId = $value = Set::classicExtract( $cohorteParams, "id" );
				if( !$value ) {
					unset( $cohorteParams['id'] );
				}
			}
			else {
				$containerId = $cohorteParams['id'] = Inflector::camelize( "{$name}_{$action}" );
			}

			$oddOptions = array( 'class' => 'odd');
			$evenOptions = array( 'class' => 'even');

			$trs = array();
			foreach( $datas as $key => $data ) {
				$iteration = 0;
				$line = array();
				foreach( $cells as $path => $params ) {
					list( $model, $field ) = $this->_modelField( $path );
					$validationErrors = ClassRegistry::init( $model )->validationErrors;

					$cohortePath = str_replace( ".", ".$key.", $path );
					$type = Set::classicExtract( $params, 'input' );
					unset( $params['input'] );

					if( !empty( $cohorteOptions ) && !isset( $params['options'] ) ) {
						$params['options'] = $cohorteOptions;
					}

					// FIXME
					if( !Set::check( $this->data, $cohortePath ) ) {
						$params['value'] = Set::classicExtract( $data, $path );
					}

					$hiddenFields = '';
					if( ( $cohorte == true ) && ( $iteration == 0 ) && !empty( $cohorteHidden ) ) {
						foreach( Set::normalize( $cohorteHidden ) as $hiddenPath => $hiddenParams ) {
							$hiddenParams = Set::merge( $hiddenParams, array( 'type' => 'hidden' ) );

							if( !Set::check( $this->data, $cohortePath ) ) {
								if( !Set::check( $hiddenParams, 'value' ) ) {
									if( Set::check( $hiddenParams, 'valuePath' ) ) {
										$hiddenParams['value'] = Set::classicExtract( $data, $hiddenParams['valuePath'] );
										unset( $hiddenParams['valuePath'] );
									}
									else {
										$hiddenParams['value'] = Set::classicExtract( $data, $hiddenPath );
									}
								}
							}
							$hiddenFields .= $this->field( str_replace( ".", ".$key.", $hiddenPath ), $hiddenParams );
						}
					}

					if( !empty( $type ) ) {
						switch( $type ) {
							case 'radio':
							case 'checkbox':
							case 'select':
							case 'text':
								$params['type'] = $type;
								$params['label'] = false;
								$params['legend'] = false;
								$params['div'] = false;

								if( !in_array( $type, array( 'select', 'radio' ) ) ) {
									unset( $params['options'] );
								}
								else if( Set::check( $cohorteParams, "options.{$model}.{$field}" ) ) {
									$params['options'] = Set::classicExtract( $cohorteParams, "options.{$model}.{$field}" );
								}

								if( !isset( $params['multiple'] ) && !in_array( $type, array( 'radio' ) ) ) {
									unset( $params['legend'] );
								}

								if( in_array( $type, array( 'radio' ) ) ) {
									unset( $params['label'] );
								}

								if( !Set::check( $this->data, $path ) ) {
									if( Set::check( $params, 'valuePath' ) ) {
										$value = Set::classicExtract( $data, $params['valuePath'] );
										unset( $params['valuePath'] );
									}
								}

								/// FIXME: avec $this->data
								if( $type == 'checkbox' && Set::check( $params, 'value' ) ) {
									$params['checked'] = ( $params['value'] ? true : false );
								}


								$tdParams = array( 'class' => "input {$type}" );
								if( Set::check( $validationErrors, "{$key}.{$field}" ) ) {
									$tdParams = addClassName( $tdParams, 'error' );
								}

								/// Error handling FIXME $modelClass
								$error = '';
								if( Set::check( $modelClass->validationErrors, "{$key}.{$field}" ) ) {
									$error = Set::classicExtract( $modelClass->validationErrors, "{$key}.{$field}" );
									if( !empty( $error ) ) {
										$tdParams['class'] = "{$tdParams['class']} error";
										$error = $this->Html->tag( 'div', $error, array( 'class' => 'error-message' ) );
									}
								}

								$line[] = $this->Html->tag( 'td', $hiddenFields.$this->field( $cohortePath, $params ).$error, $tdParams );
								break;
							default:
								$line[] = $this->Html->tag( 'td', $hiddenFields.$this->format( $data, $path, $params ) );
						}
					}
					else {
						$td = $this->format( $data, $path, Set::merge( $params, array( 'tag' => 'td' ) ) );
						$line[] = preg_replace( '/<\/td>$/', "$hiddenFields</td>", $td );
					}
					$iteration++;
				}

				$line = implode( '', $line ).$this->actions( $data, $cohorteParams );
				if( Set::check( $cohorteParams, 'tooltip' ) ) {
					$tooltip = Set::extract( $cohorteParams, 'tooltip' );
					$tooltip = $this->view( $data, $tooltip, array( 'widget' => 'table', 'class' => 'innerTable', 'id' => "innerTable{$key}" ) );
					$line .= $this->Html->tag( 'td', $tooltip, array( 'class' => 'innerTableCell noprint' ) );
				}

				$trOptions = ( ( ( $key + 1 ) % 2 ) ?  $oddOptions : $evenOptions );
				/// FIXME: prefixer l'id du conteneur si prÃ©sent + si l'id est Ã  false -> pas d'id, sinon calcul auto
				$trOptions['id'] = $containerId.'Row'.( $key + 1 );
				$trs[] = $this->Html->tag( 'tr', $line, $trOptions );
			}

			$return = '';

			/// Liste d'actions communes Ã  la table
			if( Set::check( $cohorteParams, 'add' ) ) { // FIXME: ensemble d'actions
                $actions = Set::normalize( Set::classicExtract( $cohorteParams, 'add' ) );

                // FIXME + faire un fonction, voir actions dans la table
                $actionModelField = array_keys( $actions );
                $actionModelField = $actionModelField[0];

				list( $actionModel, $actionAction ) = $this->_modelField( $actionModelField );

                $url = Set::merge(
                    array(
                        'controller' => Inflector::tableize( $actionModel ),
                        'action' => $actionAction
                    ),
                    $actions[$actionModelField]
                );

				$return .= $this->Html->tag(
					'p',
					$this->button(
						$actionAction,
						$url,
						array( 'title' => __d( $domain, "{$actionModel}::{$actionAction}", true ) )
					),
					array( 'class' => 'actions' )
				);
			}

			if( empty( $trs ) ) {
				return $return.$this->Html->tag(
					'p',
					__d( $domain, "{$modelName}::index::empty", true ),
					array( 'class' => 'notice' )
				);
			}

			$tableOptions = array();
			if( Set::check( $cohorteParams, 'tooltip' ) ) { /// FIXME: th
				$tableOptions['class'] = 'tooltips';
			}

			/// FIXME
			$paginateModel = $modelClass->name;
			if( Set::check( $cohorteParams, 'paginate' ) ) {
				$paginateModel = Set::classicExtract( $cohorteParams, 'paginate' );
			}

			$pagination = $this->Xpaginator->paginationBlock( $paginateModel, Set::merge( $this->params['pass'], $this->params['named'] ) );
			$return .= $pagination.$this->Html->tag(
				'table',
				$this->thead( $cells, $cohorteParams ).
				$this->Html->tag( 'tbody', implode( '', $trs ) ),
				$tableOptions
			).$pagination;

			if( $cohorte == true ) {
				$return = $this->Xform->create( null, array( 'url' => Set::merge( array( 'controller' => $this->params['controller'], 'action' => $this->params['action'] ), $this->params['pass'], $this->params['named'] ) ) ).$return;
			}

			/// Hidden -> FIXME
			if( ( $cohorte == true ) && Set::check( $cohorteParams, 'search' ) ) {
				foreach( Set::extract( $cohorteParams, 'search' ) as $searchModelField ) {
					$key = "Search.$searchModelField";
					$return .= $this->Xform->input( $key, array( 'type' => 'hidden' ) );
				}
			}

			if( $cohorte == true ) {
				$return .= $this->Xform->submit( __( 'Validate', true ), array( 'name' => 'cohorte' ) );
				$return .= $this->Xform->end();
				$return = $this->Html->css( array( 'cake.form' ), 'stylesheet', array( 'media' => 'all' ), false ).$return;
			}

			return $return;
		}

		/**
		*
		*/

		public function subform( $fields, $formParams = array() ) {
			$default = array();

			$fields = Set::normalize( $fields );
			foreach( $fields as $fieldName => $options ) {
				$fields[$fieldName] = Set::merge( $default, $options );
			}

			$return = '';

			foreach( $fields as $path => $params ) {
				list( $fieldModelName, $fieldModelfield ) = $this->_modelField( $path );
				$modelClass = ClassRegistry::init( $fieldModelName );

				$required = ( count( Set::extract( $modelClass->validate, "/{$fieldModelfield}[rule=notEmpty]" ) ) > 0 );
				$params = Set::merge( array( 'required' => $required ), $params );

				if( !Set::check( $params, 'options' ) && Set::check( $formParams, "options.{$fieldModelName}.{$fieldModelfield}" ) ) {
					$params['options'] = Set::classicExtract( $formParams, "options.{$fieldModelName}.{$fieldModelfield}" );
					if( !Set::check( $params, 'empty' ) ) {
						$params['empty'] = true;
					}
				}

                if( !Set::check( $params, 'domain' ) || empty( $params['domain'] ) ) {
                    $params['domain'] = Inflector::singularize( Inflector::tableize( $fieldModelName ) );
                }

				$return .= $this->Xform->input( $path, $params );
			}

			return $return;
		}

		/**
		*
		*/

		public function form( $fields, $formParams = array() ) {
			$name = Inflector::camelize( $this->params['controller'] );
			$action = $this->action;
			/// FIXME: vÃ©rifier, c'est tjs le classify du nom de la table
			$modelName = Inflector::classify( $this->params['controller'] );
			$modelClass = ClassRegistry::init( Inflector::classify( $modelName ) );
			$domain = Inflector::singularize( Inflector::tableize( $modelClass->name ) );

			$primaryKey = Set::classicExtract( $this->data, "{$modelName}.{$modelClass->primaryKey}" );

			$return = '';
			$return .= $this->Xform->create( null, array( 'inputDefaults' => array( 'domain' => $domain ) ) );

			if( !empty( $primaryKey ) ) {
				$return .= $this->Xform->input( "{$modelName}.{$modelClass->primaryKey}" );
			}

			$return .= $this->subform( $fields, $formParams );

			/// Form buttons -> FIXME: en faire une fonction
			$submit = array( 'Save' => 'submit' );
			if( Set::check( $formParams, 'submit' ) ) {
				$submit = Set::classicExtract( $formParams, 'submit' );
				if( is_string( $submit ) ) {
					$submit = array( $submit => 'submit' );
				}
			}

			$buttons = array();
			$default = array( 'type' => 'submit' );
			foreach( $submit as $value => $options ) {
				if( is_string( $options ) ) {
					$options = array( 'type' => $options );
				}
				$options = Set::merge( $default, $options );
				$options['class'] = "input {$options['type']}";
				$buttons[] = $this->Xform->button( __( $value, true ), $options );
			}

			$return .= $this->Html->tag( 'div', implode( ' ', $buttons ), array( 'class' => 'submit' ) );
			$return .= $this->Xform->end();

			return $this->Html->css( array( 'cake.form' ), 'stylesheet', array( 'media' => 'all' ), false ).$return;
		}

		/**
		*
		*/

		public function search( array $fields, array $params = array() ) {
			$domain = strtolower( Inflector::classify( $this->params['controller'] ) );

			$params['inputDefaults'] = Set::merge(
				array(
					'required' => false,
					'empty' => true,
					'domain' => $domain,
					'dateFormat' => __( 'Locale->dateFormat', true ),
				),
				Set::extract(
					$params,
					'inputDefaults'
				)
			);

			$paramsOptions = Set::extract( $params, 'options' );
			unset( $params['options'] );

			$return = $this->Xform->create( null, $params );

			foreach( Set::normalize( $fields ) as $fieldName => $options ) {
				list( $fieldModelName, $fieldModelfield ) = $this->_modelField( $fieldName );

				/// TODO: function ?
				if( Set::check( $paramsOptions, "{$fieldModelName}.{$fieldModelfield}" ) && empty( $options['options'] ) ) {
					$options['options'] = Set::classicExtract( $paramsOptions, "{$fieldModelName}.{$fieldModelfield}" );

				}

				if( $this->_fieldType( "{$fieldModelName}.{$fieldModelfield}" ) != 'date' ) {
					/// FIXME: name
					$inputParams = Set::merge( $options, array( 'name' => "data[Search][{$fieldModelName}][{$fieldModelfield}]" ) );
					if( Set::classicExtract( $this->data, "Search.{$fieldModelName}.{$fieldModelfield}" ) ) {
						$inputParams['value'] = Set::classicExtract( $this->data, "Search.{$fieldModelName}.{$fieldModelfield}" );
					}
				}
				else { /// FIXME -> date, datetime, time, .... + pour tout le monde, + domain + remanier ci-dessus
					$inputParams = $options;
					if( !Set::check( $inputParams, 'label' ) ) {
						$inputParams['label'] = __d( Inflector::singularize( Inflector::tableize( $fieldModelName ) ), $fieldName, true );
					}
					$inputParams['type'] = 'date';
					$fieldName = "Search.$fieldName";
				}

				$return .= $this->Xform->input( $fieldName, $inputParams );
			}

			$return .= $this->Xform->submit( __( 'Search', true ) );
			$return .= $this->Xform->end();

			return $this->Html->css( array( 'cake.form' ), 'stylesheet', array( 'media' => 'all' ), false ).$return;
		}

		/**
		* @param array $item
		* @param array $columns ie. array( 'User.status', 'User.userae' )
		* @param array $options
		* @return string
		* Valid keys for params:
		*	- widget -> dl, table
		*	- options ie. array( 'User' => array( 'status' => array( 1 => 'Enabled', 0 => 'Disabled' ) ) )
		*   - domain
		* TODO: $this->defaultModel() Ã  la place de $this->params, 'controller'
		*/

		public function view( $item, $columns, $options = array() ) { // FIXME: rename options en viewParams
			$widget = Set::classicExtract( $options, 'widget' );
			$widget = ( empty( $widget ) ? 'dl' : $widget );
			unset( $options['widget'] );

			$name = Inflector::camelize( Set::classicExtract( $this->params, 'controller' ) ); // FIXME -> params + params -> table/list
			$modelName = Inflector::classify( $name );

			$rows = array();
			$lineNr = 1;
			foreach( Set::normalize( $columns ) as $column => $columnOptions ) {
				list( $columnModel, $columnField ) = $this->_modelField( $column );
				$columnDomain = Inflector::singularize( Inflector::tableize( $columnModel ) );
				/// dans une fonction ?

				if( !Set::check( $columnOptions, 'domain' ) ) {
					if( Set::check( $options, 'domain' ) ) {
						$columnOptions['domain'] = $options['domain'];
					}
					else {
						$columnOptions['domain'] = $columnDomain;
					}
				}

				$formatOptions = $labelOptions = $columnOptions = addClassName( $columnOptions, ( ( $lineNr % 2 ) ?  'odd' : 'even' ) );

				unset( $columnOptions['domain'] );
				unset( $columnOptions['type'] );

				$line = $this->Html->tag(
					( ( $widget == 'table' ) ? 'th' : 'dt' ),
					$this->label( $column, $labelOptions ),
					$columnOptions
				);

				$params = array( 'tag' => ( ( $widget == 'table' ) ? 'td' : 'dd' ) );
				foreach( array( 'options', 'type', 'class', 'domain' ) as $optionsKey ) {
					if( isset( $columnOptions[$optionsKey] ) ) {
						$params[$optionsKey] = $columnOptions[$optionsKey];
					}
				}

				if( $widget == 'dl' ) {
					$params['class'] = $columnOptions['class'];
				}

                if( Set::check( $options, 'options' ) && !Set::check( $params, 'options' ) ) {
                    $params['options'] = $options['options'];
                }

				$line .= $this->format( $item, $column, Set::merge( $params, $formatOptions ) );

				if( $widget == 'table' ) {
					$rows[] = $this->Html->tag( 'tr', $line, array( 'class' => $params['class'] ) );
				}
				else {
					$rows[] = $line;
				}

				$lineNr++;
			}

			$defaultOptions = array(
// 				'id' => "{$modelName}View",
				'class' => 'view',
			);

			if( $widget == 'table' ) {
				$return = $this->Html->tag(
					'table',
					$this->Html->tag(
						'tbody',
						implode( '', $rows )
					),
					Set::merge( $defaultOptions, $options )
				);
			}
			else {
				$return = $this->Html->tag(
					'dl',
					implode( '', $rows ),
					Set::merge( $defaultOptions, $options )
				);
			}

			return $return;
		}
	}
?>